---
title: Node.js学习
published: 2026-02-10
description: 学习Node.js笔记
tags: [后端]
category: 后端
licenseName: "CC BY-NC-SA 4.0"
author: Aloha
sourceLink: "https://github.com/emn178/markdown"
image: ./images/Node.js学习cover.webp
draft: false
date: 2026-02-10 
pubDate: 2025-02-10
---

# Node.js学习

## 一、初识Node.js

### 1.1 Node.js是什么?
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用 JavaScript 编写，并且 Node.js 是一个事件驱动的，非阻塞的，基于 I/O 的异步操作的 JavaScript 运行环境。

### 1.2 Node.js的核心特性
Npde.js 的核心特性有：
- 基于事件驱动，非阻塞的异步 I/O
- 模块化
- 跨平台
- 快速、高效
- 丰富的第三方模块

### 使用Node运行JavaScript代码
Node.js 运行 JavaScript 代码的方式有很多，最常用的是使用 Node.js 的命令行工具。
当我们要使用Node运行一个js文件时，可以使用以下命令：
```bash
node Node_Example.js
# 运行结果：
HELLO Node.js
```
## 二、Node.js 的模块系统

## 2.1 fs模块
fs模块是Node.js最常用的模块，主要是对文件进行读写、创建、删除、修改、移动等操作。

它的导入方法也很简单，使用require()方法导入即可
```javascript
const fs = require('fs');
```
### 2.1.1 读取文件内容

```javascript
# // 导入fs 模块
const fs = require('fs')
// 操作文件
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) {
    # // 打印失败的结果
    # // 如果读取成功则err的值为null
    # // 如果读取失败则err的值为错误信息 undefined
    console.log(err);
    console.log("-----");
    # // 打印成功的结果
    console.log(dataStrs);
})

# 1.txt 文件内容的输出结果:
null
-----
1111
```

### 2.1.2 异步读取文件

```javascript
const fs = require('fs')
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message)
    }
    return console.log('文件读取成功', dataStrs)
})
# 输出结果:
文件读取成功 1111
```

### 2.1.3 写入文件内容
- 使用fs.writeFile()方法写入文件内容, 可以向指定的文件中写入内容，语法格式如下:

```javascript
fs.writeFile(file, data[, options], callback])
```
- 注意：当我们重复调用fs.writeFile()方法写入文件的时候，会覆盖掉之前的内容。

- fs.writeFile()的示例代码:

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/2.txt', 'hello world', function(err){
# // 如果没有出错，则返回null，如果出错，则返回错误信息
    console.log(err);
})
# 输出结果:
null
```

### 2.1.4 异步写入文件内容

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/3.txt', 'hello world', function(err){
// 如果没有出错，则返回null，如果出错，则返回错误信息undefined
if(err){
    return console.log('写入失败', err.message)
}
    console.log('3.txt,写入成功');
})
# 输出结果为:
3.txt,写入成功
```
### 2.1.5 成绩整理案例：

此案例是结合前面fs模块的读写操作进行对成绩.txt文件的操作，将读取到的内容进行整理，并写入新的文件中。

```javascript
const fs = require('fs')
fs.readFile('./files/成绩.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message);
    }
    console.log('文件读取成功', dataStrs);

    // 1.将数据进行分割
    const arrOld = dataStrs.split(' ')
    console.log(arrOld);

    // 2.遍历分割后的数据成为一个新数组
    const arrNew = []
    arrOld.forEach(item => {
        arrNew.push(item.replace('=', ': '))
    });
    console.log(arrNew);

    // 3.进行数据的拼接
    const newStr = arrNew.join('\r\n')
    console.log(newStr);
    
    // 4.将拼接后的数据写入到文件中
    fs.writeFile('./files/整理后的成绩.txt', newStr, function (err) { 
        if (err) {
            return console.log('文件写入失败', err.message)
        }
        return console.log('文件写入成功')
})
})

// 输出结果：
小红: 99
小白: 100
小黄: 70
小黑: 66
小绿: 88
文件写入成功
```

### 2.1.6 fs模块-路径动态拼接的问题

在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的相对路径，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径

示例代码：

```javascript
const fs = require('fs')

fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})

```
```bash
# 当我们没有处在node.js的根目录下时，在控制台执行以下命令时，会出现报错，文件无法被读取
node ./code/ndoe 动态路径错误问题.js
```

- 解决方法：使用`__dirname`来获取当前文件的所在目录，并拼接成完整的文件路径

示例代码:

```javascript
const fs = require('fs')

fs.readFile(__dirname + './files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})
```

## 2.2 path路径模块

### 2.2.1 什么是path路径模块?
path模块是Node.js中官方提供，用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径处理的需求

例如:
- `path.join()`方法用来拼接路径`
- `path.basename()`方法用来从路径字符串中，将文件名解析出来`

当然如果要在JavaScript代码中，使用path模块来处理路径，则需要先导入模块，代码如下:

```javascript
const path = require('path');
```

### 2.2.2 path.join()方法

使用`path.join()`方法来拼接路径，可以把多个路径片段拼接成一个完整的路径字符串,代码如下:

- 示例一:

```javascript
// 导入模块
const path = require('path')
const pathStr = path.join('/a', '/b/c', '../', './d','e')
// 注意../是可以抵消一层路径的
console.log(pathStr) // 输出结果: \a\b\d\e
```

- 示例二:

```javascript
// 导入模块
const path = require('path')
const pathStr1 = path.join(__dirname, './files/1.txt')
console.log(pathStr1) 

// 输出结果: D:\Node.js基础\day1\CODE.\files\1.txt
// 这里是根据我电脑上的路径来写的,只做演示作用
```
示例二的方法更加方便简洁，因此在实际开发中，我们推荐使用示例二。


在今后的开发中，凡是涉及到路径拼接的操作，都要使用path.join()方法来拼接路径，不要直接使用 + 进行字符串的拼接

- 示例代码:

```javascript
const fs = require('fs');
const path = require('path');

fs.readFile(path.join(__dirname, '/files/example.txt'), 'utf8', (err, dataStr) => {
    if (err) {
        console.error('文件读取失败', err.message);
    }
    console.log(dataStr);
})

// 输出结果:
path.join路径演示
```

### 2.2.3 path.basename()方法

#### path.basename() 的语法格式:
使用path.basename()方法可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:

```javascript
path.basename(pathp[, ext])
```

- path <string> 必选参数
- ext <string> 可选参数, 表示文件扩展名
- 返回: <string> 表示路径中的最后一部分

#### path.basename() 的使用示例:

```javascript
const path = require('path');
const fpath = '/a/b/c/index.html';

var fullName = path.basename(fpath);
console.log(fullName); // 输出结果: index.html
```

```javascript
const path = require('path')
const gpath = '/a/b/c/index.html'

// 参数二为可选参数, 表示文件扩展名
var nameWithoutExt = path.basename(gpath, '.html')
consolo.log(nameFullName) // 输出结果: index
```

### 2.2.4 path.extname()
#### path.extname()的语法格式:

使用path.extname()方法,可以获取路径中你的扩展名部分, 语法格式如下:

```javascript
path.extname(path)
```

- path<string>必选参数，表示一个路径的字符串
- 返回<string>返回得到的扩展名字符串

#### path.extname()的代码示例:

```javascript
const path = require('path')
// 这是文件的存放路径
const fpath = '/a/b/c/index.html'

const fext = path.extname(fpath)
console.log(fext)

// 输出结果：.html
```

### 2.2.5 时钟案例

接下来我将演示一个时钟案例，此案例目的是为了能够让学习者更好的理解node.js中模块化的设定和使用。

这是我们要解耦的html文件中的源码:
可以看到该源码中包含了`css` 和 `javascript`部分 后面我们将对这`两部分`进行解耦

```javascript collapse={20-75}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>index首页</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-image: linear-gradient(to bottom right, red, gold);
    }

    .box {
      width: 400px;
      height: 250px;
      background-color: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      box-shadow: 1px 1px 10px #fff;
      text-shadow: 0px 1px 30px white;

      display: flex;
      justify-content: space-around;
      align-items: center;
      font-size: 70px;
      user-select: none;
      padding: 0 20px;

      /* 盒子投影 */
      -webkit-box-reflect: below 0px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0%, transparent), to(rgba(250, 250, 250, .2)));
    }
  </style>
</head>

<body>
  <div class="box">
    <div id="HH">00</div>
    <div>:</div>
    <div id="mm">00</div>
    <div>:</div>
    <div id="ss">00</div>
  </div>

  <script>
    window.onload = function () {
      // 定时器，每隔 1 秒执行 1 次
      setInterval(() => {
        var dt = new Date()
        var HH = dt.getHours()
        var mm = dt.getMinutes()
        var ss = dt.getSeconds()

        // 为页面上的元素赋值
        document.querySelector('#HH').innerHTML = padZero(HH)
        document.querySelector('#mm').innerHTML = padZero(mm)
        document.querySelector('#ss').innerHTML = padZero(ss)
      }, 1000)
    }

    // 补零函数
    function padZero(n) {
      return n > 9 ? n : '0' + n
    }
  </script>
</body>

</html>
```

- 创建一个clock.js文件

创建一个名为clock.js的文件，并写入以下代码:

```javascript collapse={20-78}
// 1.导入模块
const fs = require('fs')
const path = require('path')

// 2.创建正则表达式,用于匹配对应的字符串
// 2.1.匹配style标签
const regiStyle = /<style>[\s\S]*<\/style>/
// 2.2.匹配script标签
const regiScript = /<script>[\s\S]*<\/script>/

// 调用fs.readFile()方法,读取文件
fs.readFile(path.join(__dirname, './index.html'), 'utf8', function (err, dataStr) {
    if(err) {
        return console.log('读取文件失败！' + err.message)
    }
    console.log('读取文件成功！', dataStr)

    // 调用方法, 传入dataStr读取到的内容

    // 1.拆分HTML中的Css结构方法
    resoloveCss(dataStr)

    // 2.拆分HTML中的JS结构方法
    resolveJs(dataStr)

    // 3.创建Html文件
    resolveHtml(dataStr)

})

// 创建方法
// 1.resolve CSS 方法
function resoloveCss(htmlStr) {
    // 1.提取(匹配html页面中符合条件的字符串)
    const r1 = registStyle.exec(htmlStr)
    console.log(r1);
    
    // 2.替换
    const newCss = r1[0].replace('<style>', '').replace('</style>', '')
    console.log('替换后的newHtml为:', newCss);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newCss.css'), newCss, function (err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
} 

// 2.resolveJs()方法
function resolveJs(htmlData) {
    // 1.提取(符合的字符串) 匹配成功则返回数组,失败则返回null
    const s1 = registScript.exec(htmlData)
    console.log(s1);
    // 2.替换
    const newS1 = s1[0].replace('<script>', '').replace('</script>', '')
    console.log('newS1替换结构为:', newS1);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newJs.js'), newS1, function(err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}

// 3.创建Html文件
function resolveHtml(htmlData) {
    const newHtml = htmlData.replace(registStyle, '<link rel="stylesheet" href="./newCss.css">').replace(registScript, '<script src="./newJs.js"></script>')
    console.log('newHtml打印结果:', newHtml);
    
    fs.writeFile(path.join(__dirname, './files/newHtml.html'), newHtml, function(err) { 
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}
```

运行这个代码，会生成一个名为 `newHtml.html` 的文件，并写入新的 HTML 内容。
将`原本的index.html`中`html css javascript`的内容全部分离出来，并逐个写入`新的文件`中,最后在通过`html的link方法引入css和JavaScript文件`，完成页面的`模块化`，这点与Vue框架并无太大差别

## 2.3 http模块

### 2.3.1 什么是http模块？
在认识到`http模块`之前，我们先了解一些`概念`：

- 什么是客户端，什么是服务器?

    在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

- 而http模块是什么呢?

    `http模块`是Node.js官方提供的、用来`创建Web服务器的模块`。通过http模块提供的`http.createServer()`方法，就能方便的把一台普通电脑，变成一台Web服务器，从而对外提供web资源服务。

### 2.3.2 如何使用http模块

如果希望使用http模块，首先需要引入该模块：

```javascript
const http = require('http');
```

### 2.3.3 进一步理解http模块的作用

服务器和普通电脑的`区别`在于，服务器上安装了web服务器软件，例如：IIS、`Apache`等。通过安装这些服务器软件，就能把一台电脑变成一台web服务器。

在Node.js中，我们不需要使用IIS、Apache等这些第三方服务器软件，因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。

### 2.3.4 服务器相关的概念

1. #### IP地址：

    `IP地址`就是相当于互联网上每台计算机的唯一地址，因此IP地址具有唯一性，如果把“个人电脑”比作一台电话，那么IP地址就是这个电话的电话号码，只有在知道对方IP地址的前提下，才能对应电脑之间进行数据通信。

    `IP地址的格式`: 通常用`点分十进制`表示成(`a.b.c.d`)的形式，其中a,b,c,d都是0-255之间的十进制整数。例如：用点分十进制表示的IP地址(192.168.1.1)

    - 注意:

        1. `互联网中每台web服务器，都有自己的IP地址`， 例如：大家可以在Windows的终端中运行 `ping www.baidu.com` 命令，就会看到百度的IP地址。

        2. 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP地址，就可以访问到自己的电脑。

2. #### `域名`和`域名服务器`

    尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，`不直观`，而且`不方便于记忆`，雨伞人们又发明了另一套字`符串型`的`地址方案`，即所谓的`域名(Domain Name)地址`。

    `IP地址`和`域名`是`一一对应的关系`，这份对应关系存放在一种叫做`域名服务器`(DNS, Domain Name Server)的电脑中。只需要通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现，因此，`域名服务器就是提供IP地址和域名之间的转换服务的服务器`

    - 注意:

        1. 单纯使用IP地址，互联网中的电脑也能够正常工作，但是有了域名的加持，能让互联网的世界变得更加方便。

        2. 在开发测试期间， `127.0.0.1`对应的域名是`localhost`，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

3. #### 端口号

    计算机中的端口号，就好像是现实生活中的门牌号一样，通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你手中。

    同样的道理，在一台电脑中，可以运行成百上千个web服务，每个web服务都对应一个唯一的端口号，客户端发送过来的网络请求，通过端口号，可以被准确地交给`对应的web服务`进行处理

    - 注意:
        1. 每个端口号不能同时被多个web服务占用
        2. 在实际应用中，URL中的80端口可以被省略

### 2.3.5 创建最基本的web服务器

1. #### 创建web服务器的基本步骤
    1. 导入http模块
    2. 创建web服务器实例
    3. 为服务器实例绑定`request`事件，`监听客户端的请求`
    4. 启动服务器

    2. #### 步骤一 - 导入http模块

    ```javascript
    const http = require('http');
    ```

    3. #### 步骤二 - 创建web服务器实例

        调用`http.createServer()`方法创建一个web服务器实例

    ```javascript
    const server = http.createServer();
    ```

    4. #### 步骤三 - 为服务器实例绑定`request`事件，`监听客户端的请求`

        为服务器实例绑定`request`事件，即可监听客户端发送的网络请求

    ```javascript
    // 使用服务器实例的 .on 方法，为服务器实例绑定 request 事件
    server.on('request', (req, res) => {
        // 只要有客户端来请求外卖自己的服务器，就会触发request事件，从而调用这个事件处理函数
        console.log('Someone has made a request to our server!');
    })
    ```

    5. #### 步骤四 - 启动服务器

        调用服务器实例的 .listen 方法，即可启动当前的web服务器实例:

    ```javascript
    // 调用server.listen(端口号，cb回调)， 即可启动服务器
    server.listen(80, () => {
        console.log('Our server is running!');
    })
    ```

2. #### req请求对象

    只要服务器接收到了客户端的请求，就会调用通过`server.on()`为服务器绑定`request事件处理函数`

    如果想在事件处理器函数中，`访问与客户端相关的数据或属性`, 可以使用如下的方式:

    ```javascript
    const http = require('http');
    const server = http.createServer();
    server.on('request', (req) => {
        // req是请求对象，它包含了与客户端相关的数据和属性，例如:
        // req.url 是客户端请求的URL地址
        const url = req.url;
        // req.method 是客户端的method请求类型
        const method = req.method;
        // 拼接url和method  
        const str = `You request url is ${method} and request method is ${url}`;
        // 打印str
        console.log(str);

    })
    server.listen(80, () => {
        console.log('server running at http://127.0.0.1');
    })
    ```

### 2.3.6 res响应对象

在服务器的request事件处理函数中，`如果想访问与服务器相关的数据或属性`,可以使用如下的方式：

```javascript
server.on('request', (req, res) => {
    //  res 是响应对象，它包含了与服务器相关的数据和属性，例如：
    // 要发送到客户端的字符串
    const str = `You request url is ${req.url} and request method is ${req.method}`
    // res.end 方法的作用:
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})
```

#### 解决`中文乱码`问题

当调用res.end()方法时，Node.js会默认将数据转换成UTF-8编码，但是对于中文字符，这个编码方式能会导致乱码, 此时, 需要手动设置内容的编码格式, 解决办法也很简单, 设置响应头
Content-Type: text/html; charset=utf-8即可

```javascript
server.on('request', (req, res) => {
    const str = '中文乱码'
    // 设置响应头
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    // 返回响应数据
    res.end(str)
})
```

### 2.3.7 根据不同的url响应不同的html内容

1. 核心实现步骤
    - 获取`请求的url地址`
    - 设置`默认的响应内容`为`404 Not Found`
    - 判断用户请求的是否为`/`或者`/index.html`首页
    - 判断用户请求的是否为`/about.html`关于页面
    - 设置Content-Type响应头
    - 使用`res.end()`方法把内容，响应给客户端

2. 示例代码

    ```javascript
    const http = require('http');
    const server = http.createServer()
    server.on('request', (req, res) => {
        const url = req.url;
        // 设置默认的内容为 404 Not Found
        let content = `<h1>'404 Not Found'</h1>`;
        if(url === '/') {
            content = `<h1>'首页'</h1>`;
        }else if(url === '/about.html') {
            content = `<h1>'关于'</h1>`;
        }
        // 设置响应头 防止中文乱码
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        // 返回 页面content 的响应内容
        res.end(content);
    })
    server.listen(80, () => {
        console.log('http server running at http://127.0.0.1');
    })
    ```

### 2.3.8 http时钟web服务器案例

在path路径模块的章节中，我们已经实现了一个http时钟服务器，现在我们来实现一个http时钟服务器，这个服务器会返回当前时间。

```javascript
const fs = require('fs');
const path = require('path');
const http = require('http');

const server = http.createServer();

server.on('request',(req,res) => { 

    const url = req.url;
    // 这里的所表达的意思是代表根目录的意思
    const fpath = path.join(__dirname, url);

    fs.readFile(fpath, 'utf-8', (err, dataStr) => {
        if(err) {
            res.end('404 Not Found')
            return
        }
        res.end(dataStr)
    })
   
})
server.listen(80, () => {
    console.log('http server running at http://127.0.0.1');
})
```

`需要注意的时候，当我们运行这个服务器，进入的默认URL是空路径，也就是根目录，需要我们手动在网址输入框添加/clock/index.html路径访问这个文件夹中的html文件，才能显示页面。`

## 三、Node.js中的模块化

## 3.1 什么是模块化?

在编程领域中的模块化，就是`遵守固定的规则`，把一个大文件拆成`独立并互相依赖`的`多个小模块`。

把代码进行模块化拆分的好处是:

1. 提高了代码的`复用性`
2. 提高了代码的`可维护性`
3. 可以实现`按需加载`


## 3.2 模块化的规范

`模块化规范`就是对代码进行模块化的拆分与组合时，需要遵守的那些规则

例如:
1. 使用什么样的语法格式来`引用模块`
2. 在模块中使用什么样的语法格式`向外暴露成员`

`模块化规范的好处：` 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。

## 3.3 Node.js 中模块化的分类

Node.js中根据模块来源的不同，将模块分为了3大类，分别是：

1. 内置模块(内置模块是由Node.js官方提供的, 例如`fs`、`path`、`http`等)
2. 自定义模块(用户创建的每个.js文件,都是自定义模块)
3. 第三方模块(由第三方开发出来的模块，例如`express`、`mongoose`、`lodash`等)

## 3.4 加载模块

使用强大的require()方法，可以加载内置模块、用户自定义模块、第三方提模块进行使用。

例如:

```javascript
// 1. 加载内置模块
const fs = require('fs');
// 2.加载自定义模块 (提供自定义模块的路径)
const myModule = require('./myModule');
// 3.加载第三方模块
const request = require('request');
```

- 值得注意的是，require()方法返回的是一个对象，对象中包含`模块的导出内容`。同时，require()方法会`缓存模块`，即多次调用require()方法，返回的都是同一个对象。

- 关于在使用require加载用户自定义模块期间是可以`省略.js后缀`的，例如：`require('./myModule')`。

- 关于使用require()方法加载第三方模块，`require()`方法会自动将模块路径中的`./`转换成`__dirname`。例如：`require('./myModule')`会被转换成`require(__dirname + '/myModule')`。


## 3.5 Node.js中的模块作用域

### 3.5.1 什么是模块作用域？

和`函数作用域`类似，在自定义模块中定于的`变量`、`方法`等成员，只能在当前模块内被访问。这种`模块级别的访问限制`，叫做`模块作用域`。


当我们定义了一个自定义模块命名为custom.js 在其模块内部定义一个函数：
```javascript
const username = '张三'

function showName() {
    console.log('我的名字是' + username)
}
```

当我们在其他模块中引用这个模块时，无法直接访问模块内部定义的变量和函数：

```javascript
const custom = require('./custom')

console.log(custom) // 输出空对象
```

#### 模块作用域的好处：模块作用域能够很好的防止全局变量污染的问题

### 3.5.2 向外共享模块作用域中的成员

1. `module`对象 

在每个.js自定义模块中都有一个module对象，它里面`存储了和当前模块的有关的信息` 我们可以在控制台打印`module`

```javascript
console.log(module)

// module对象 输出结果：
{
  id: '.',
  path: 'D:\\Node.js基础\\day2',
  exports: {},
  filename: 'D:\\Node.js基础\\day2\\07.module属性.js',
  loaded: false,
  children: [],
  paths: [
    'D:\\Node.js基础\\day2\\node_modules',
    'D:\\Node.js基础\\node_modules',
    'D:\\node_modules'
  ],
  Symbol(kIsMainSymbol): true,
  Symbol(kIsCachedByESMLoader): false,
  Symbol(kURL): undefined,
  Symbol(kFormat): undefined,
  Symbol(kIsExecuting): true
}
```

module对象是一个大对象，在这个大对象中包含许多属性，其中对象中有 exports 属性，这个属性是一个对象，这个对象就是我们向模块外共享的成员。

2. `module.exports` 对象

在自定义模块中，可以使用module.exports对象，将模块中的成员共享出去。

这里我们自定义一个模块，在模块中定义一个变量，并使用module.exports对象将变量共享出去。

```javascript
module.exports.username = '张三'

module.exports.showName = function () {
    console.log('我的名字是' + this.username)
}
```

在其他模块中，可以通过require方法加载模块，并获取模块中的成员。

```javascript
const username= require('./modules/自定义模块')

console.log(username)

// username的输出结果是一个对象:
{ username: '张三', showName: [Function (anonymous)] }
```

当然，外界在使用require方法导入自定义模块时，得到的就是module.exports所指向的对象。

3. 共享成员时的`注意点`

使用require方法导入模块时，导入的结果，永远以module.exports指向的对象为准

这里我们依旧定义一个自定义模块,进行演示

```javascript
module.exports.username = '张三'
module.exports.age = 18
module.exports.showName = function () {
    console.log('我的名字是' + this.username)
}

// 为module.exports提供一个全新对象
module.exports = {
    nickname: '小张',
    age: 19,
    showName: function () {
        console.log('我的名字是' + this.nickname)
    }
}
```

在外部引用我们自定义好的模块

```javascript
const username = require('./modules/自定义模块2')

console.log(username);

// 输出结果：
{ nickname: '小张', age: 19, showName: [Function: showName] }
```

我们不难发现，module.exports是有赋值的，新的值会覆盖掉旧的值。


4. `exports`对象

由于modules.exports单词写起来笔记复杂，为了简化向外共享成员的代码，Node提供了`exports`对象。`默认情况下，exports和module.exports指向同一个对象`，最终共享的结果，还是以module.exports为准。

```javascript
console.log(exports);

console.log(module.exports);

console.log(exports === module.exports);

// 输出结果:
{}
{}
true
```

5. exports 和 module.exports 的使用误区 

需要注意的是，require()模块时，得到的永远是module.exports指向的对象

`这里我们定义一个模块用于演示二者的关系`

```javascript
exports.a = 1;
module.exports = {
    b: 2
    c: 3
};
```

显而易见的是，当我们外部引用此模块并打印出`对象的属性`时，`得到的是module.exports指向的对象，即{b: 2, c: 3}`

那么，exports和module.exports指向的顺序反过来呢？我们可以尝试一下：

```javascript
module.exports.a =1
exports = {
    b: 2
    c: 3
};

// 输出结果:
{a: 1 }
```

从以上的输出结果来看，无论`顺序如何变化`，我们`得到的永远是module.exports指向的对象`

当我们同时使用exports和module.exports定义两个变量，又会发送什么呢？这里我们举一个实例

```javascript
exports.a = 1;
module.exports.b = 2;

// 输出结果:
{ a: 1, b: 2 }
```
从该实例的输出结果来看，我们发现当`exports和module.exports在定义不同变量时候`，彼此并不会`冲突`，而是会合并成一个对象，并返回给调用者。

## 3.6 CommonJS模块化规范

Node.js遵循了CommonJS模块化规范,CommonJS规定了`模块的特效`和`各模块之间如何相互依赖。`

#### CommonJS的规定:

1. 每个模块内部，`module变量`代表当前模块
2. module变量是一个对象，它的exports属性(即`module.exports)是对外的接口`)
3. 加载某个模块，其实是加载该模块的module.exports属性, `require()方法用于加载模块`。

## 3.7 npm与包

### 3.7.1 什么是包？

Node.js中的`第三方模块`又叫做`包`

#### 1. 包的来源：

不同于Node.js中的内置模块与自定义模块，`包是由第三方个人或团队开发出来的`, 免费供所有人使用
Node.js中的包都是免费且开源的，不需要付费即可免费下载使用

#### 2. 为什么需要包?

由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发时，代码量会非常大，因此，Node.js提供了第三方模块，使得开发人员可以快速开发项目，省去很多重复的代码编写工作。

`包是基于内置模块封装出来的`，提供了更高级，更方便的API，`极大的提高了开发效率`。

`包`和`内置模块`之间的关系，类似于`JQuery`和`浏览器内置API`之间的关系。

#### 3. 从哪里下载包？

国外有一家IT公司，叫做npm, Inc.这家公司旗下有一个非常著名的网站: https://www.npmjs.com/ ，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心!

到目前位置，全球约1100 多万的开发人员，通过这个包共享平台，开发并共享了超过120 多万个包供我们使用。npm, Inc.公司提供了一个地址为 https://registry,npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。

#### 4. 如何下载包？


npm, Inc.公司提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry,npmjis.org/ 服务器把需要的包下载到本地使用。

这个包管理工具的名字叫做 Node Package Manager(简称 npm包管理工具)，这个包管理工具随着Node.js的安装包一起被安装到了用户的电脑上。

大家可以在终端中执行npm -v命令，来查看自己电脑上所安装的npm包管理工具的版本号


### 3.7.2 npm 初体验

初次装包完成后，在项目文件夹中多一个叫node_modules的文件夹，里面存放着npm安装的包和`package-lock.json`的配置文件

其中`node_modules`用来`存放所有已安装到项目中的包`。require()导入第三方包时，就是从这个目录查找并加载包。

`package-lock.json`文件用来记录`node_modules中安装的包的下载信息`，例如包的名字、版本号、下载地址等。

#### 1. 安装指定版本的包

默认情况下，使用npm install命令安装包的时候，汇总的安装最新版本的包，如果需要安装指定版本的包，可以在包名之后，通过`@符号`指定版本号， 例如:

```bash
npm install express@4.17.1
```

#### 2.包的`语义化`版本规范

包的版本是以 "点分十进制" 形式进行定义的，总共有三位数字，例如4.17.1

其中每一位数字的含义如下：

1. 主版本号
2. 功能版本
3. Bug修改版本

#### 3.多人协作问题

由于`第三方包的体积过大`，不方便团队成员之间共享项目源代码

解决方案也很简单, `只需要共享时剔除node_modules`

在项目根目录中，创建一个叫做package.json的配置文件，即可用来记录项目中安装了哪些包，
从而方便剔除node_modiles目录之后，在团队成员之间共享项目的源代码。

`今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore 忽略文件中`

#### 4.快速创建package.json

npm包管理工具提供了一个`快捷命令`，可以在`指向命令时所处的目录中`，快速创建package,json这个包管理

```bash
npm init -y
```

1. 值得注意的是 `npm init -y` 该命令只能在英文的目录下成功运行并且`只需运行一遍`
2. 运行npm install 命令安装包的时候，npm包管理工具会自动把`包的名称`和`版本号`,记录到package.json中。

### 3.7.3 `dependencies`节点

在package.json文件中，有一个`dependencies`节点，专门用来记录使用npm install命令安装了哪些包。

### 3.7.4 `devDependencies`节点

如果某些包`只在项目开发阶段`会用到，在`项目上线之后不会用到`，则建议把这些包记录到`devDependencies`节点中。

与之对应的，如果某些包在`开发`和`项目上线之后`都需要用到，则建议把这些包记录到`dependencies`节点中。

可以使用以下命令将包记录到`Devdependencies`节点中

```bash
# 简写
npm i 包名 -D

# 完整写法
npm install 包名 --save-dev
```

### 3.7.5 卸载包命令

```bash
npm uninstall
```

### 3.7.6 包的分类

使用npm包管理工具下载的包，共分为两大类，分别是:
1. 项目包

    那些被安装到`项目` `node_modules`目录中的包，都是项目包。

2. 全局包

    2.1 `开发依赖包`(被记录到devDependencies节点中的包，只会在开发期间用到)

    2.2 `核心依赖包`(被记录到dependencies节点中的包，在开发期间和项目上线之后都会用到)

    在执行npm install命令时，如果提供了`-g`参数， 则会把包安装为`全局包`。

    ```bash
    # 安装全局包
    npm -intall 包名 -g

    # 卸载全局包
    npm uninstall 包名 -g
    ```

    - 注意：

        1. 只有`工具性质的包`，才有全局安装的必要性，因为它们提供了好用的终端命令。

        2. 判断某个包是否需要全局安装才能使用，可以`参考官方提供的使用说明`即可。

### 3.7.7 i5ting_toc morkdown转换html模块

i5ting_toc是一个可以把md文档转为html页面的小工具，使用步骤如下:

```bash
npm install -g i5ting_toc

i5ting_toc -f 要转换的md文件路径 -o
```

### 3.7.8 规范的包结构

在清楚了包的概念，以及如何下载和使用包之后，接下来，我们深入了解以下`包的内部结构

一个规范的包，它的组成结构，必须符合以下3点要求:

1. 包必须以`单独的目录`而存在
2. 包的顶级目录下的要必须包含`package.json`这个包管理配置文件
3. package.json中必须包含`name,version,main`这三个属性，分别代表`包的名字、版本号、包的入口`

### 3.7.9 开发属于自己的包

1. 需要实现的功能

    1.1 `格式化日期`

    1.2 `转义`HTML中的`特殊字符`

    1.3 `还原`HTML中的`特殊字符`

2. 初始化包的基本结构

    2.1 新建tools文件夹，作为`包的根目录`
    
    2.2 在tools文件夹中，新建如下三个文件：

    1. package.json(包管理配置文件)

    2. index.js(包的入口文件)
    
    3. README.md(包的说明文档)

    - 初始化package.json文件

    ```json
    {
    "name": "tools",
    "version": "1.0.0",
    "main": "index.js",
    "description": "提供了格式化时间, HTMLEscape相关的功能",
    "keywords": [
        "itheima",
        "dateformat",
        "escape"
    ],
    "license": "ISC"
    }
    ```

    - 在index.js中定义方法

    ```javascript collapse={20-58}
    // 这是包的入口文件
    function dateFormat(dateStr) {
        const dt = new Date(dateStr)

        const y = padZero(dt.getFullYear())
        const m = padZero(dt.getMonth() + 1)
        const d = padZero(dt.getDate())

        const hh = padZero(dt.getHours())
        const mm = padZero(dt.getMinutes())
        const ss = padZero(dt.getSeconds())

        return `${y}-${m}-${d}-${hh}-${mm}-${ss}`
    }

    // 提供补零方法
    function padZero(n) {
       return n > 9 ? n : '0' + n
    }

    // html转义方法
    function htmlEscape(htmlStr) {
        return htmlStr.replace(/<|>|"|&/g, (match) => {
            switch(match) {
                case '<':
                    return '&lt;'
                case '>':
                    return '&gt;'
                case '"':
                    return '&quot;'
                case '&':
                    return '&amp;'
            }
        })
    }

    // html还原方法
    function htmlReturn(str) {
        return str.replace(/&lt;|&gt;|&quot;|&amp;/g, (match) => {
            switch(match) {
                case '&lt;':
                    return '<'
                case '&gt;':
                    return '>'
                case '&quot;':
                    return '"'
                case '&amp;':
                    return '&' 
            }
        })
    }

    // 暴露方法
    module.exports = {
        dateFormat,
        htmlEscape,
        htmlReturn
    }
    ```

3. 将不同的功能进行模块化拆分

    3.1 将格式化时间的功能，拆分到src -> `dateForamt.js`中

    3.2 将处理HTML字符串的功能，拆分到src -> `htmlEscape.js`中

    3.3 在index.js中，导入两个模块，得到需要向外共享的方法

    3.4 在index.js中，使用modules.exports把对应的方法共享出去