---
title: Node.js学习
published: 2026-02-10
description: 学习Node.js笔记
tags: [后端]
category: 后端
licenseName: "CC BY-NC-SA 4.0"
author: Aloha
sourceLink: "https://github.com/emn178/markdown"
image: ./images/Node.js学习cover.webp
draft: false
date: 2026-02-10 
pubDate: 2025-02-10
---

# Node.js学习

## 一、初识Node.js

### 1.1 Node.js是什么?
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用 JavaScript 编写，并且 Node.js 是一个事件驱动的，非阻塞的，基于 I/O 的异步操作的 JavaScript 运行环境。

### 1.2 Node.js的核心特性
Npde.js 的核心特性有：
- 基于事件驱动，非阻塞的异步 I/O
- 模块化
- 跨平台
- 快速、高效
- 丰富的第三方模块

### 使用Node运行JavaScript代码
Node.js 运行 JavaScript 代码的方式有很多，最常用的是使用 Node.js 的命令行工具。
当我们要使用Node运行一个js文件时，可以使用以下命令：
```bash
node Node_Example.js
# 运行结果：
HELLO Node.js
```
## 二、Node.js 的模块系统

## 2.1 fs模块
fs模块是Node.js最常用的模块，主要是对文件进行读写、创建、删除、修改、移动等操作。

它的导入方法也很简单，使用require()方法导入即可
```javascript
const fs = require('fs');
```
### 2.1.1 读取文件内容

```javascript
# // 导入fs 模块
const fs = require('fs')
// 操作文件
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) {
    # // 打印失败的结果
    # // 如果读取成功则err的值为null
    # // 如果读取失败则err的值为错误信息 undefined
    console.log(err);
    console.log("-----");
    # // 打印成功的结果
    console.log(dataStrs);
})

# 1.txt 文件内容的输出结果:
null
-----
1111
```

### 2.1.2 异步读取文件

```javascript
const fs = require('fs')
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message)
    }
    return console.log('文件读取成功', dataStrs)
})
# 输出结果:
文件读取成功 1111
```

### 2.1.3 写入文件内容
- 使用fs.writeFile()方法写入文件内容, 可以向指定的文件中写入内容，语法格式如下:

```javascript
fs.writeFile(file, data[, options], callback])
```
- 注意：当我们重复调用fs.writeFile()方法写入文件的时候，会覆盖掉之前的内容。

- fs.writeFile()的示例代码:

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/2.txt', 'hello world', function(err){
# // 如果没有出错，则返回null，如果出错，则返回错误信息
    console.log(err);
})
# 输出结果:
null
```

### 2.1.4 异步写入文件内容

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/3.txt', 'hello world', function(err){
// 如果没有出错，则返回null，如果出错，则返回错误信息undefined
if(err){
    return console.log('写入失败', err.message)
}
    console.log('3.txt,写入成功');
})
# 输出结果为:
3.txt,写入成功
```
### 2.1.5 成绩整理案例：

此案例是结合前面fs模块的读写操作进行对成绩.txt文件的操作，将读取到的内容进行整理，并写入新的文件中。

```javascript
const fs = require('fs')
fs.readFile('./files/成绩.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message);
    }
    console.log('文件读取成功', dataStrs);

    // 1.将数据进行分割
    const arrOld = dataStrs.split(' ')
    console.log(arrOld);

    // 2.遍历分割后的数据成为一个新数组
    const arrNew = []
    arrOld.forEach(item => {
        arrNew.push(item.replace('=', ': '))
    });
    console.log(arrNew);

    // 3.进行数据的拼接
    const newStr = arrNew.join('\r\n')
    console.log(newStr);
    
    // 4.将拼接后的数据写入到文件中
    fs.writeFile('./files/整理后的成绩.txt', newStr, function (err) { 
        if (err) {
            return console.log('文件写入失败', err.message)
        }
        return console.log('文件写入成功')
})
})

// 输出结果：
小红: 99
小白: 100
小黄: 70
小黑: 66
小绿: 88
文件写入成功
```

### 2.1.6 fs模块-路径动态拼接的问题

在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的相对路径，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径

示例代码：

```javascript
const fs = require('fs')

fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})

```
```bash
# 当我们没有处在node.js的根目录下时，在控制台执行以下命令时，会出现报错，文件无法被读取
node ./code/ndoe 动态路径错误问题.js
```

- 解决方法：使用`__dirname`来获取当前文件的所在目录，并拼接成完整的文件路径

示例代码:

```javascript
const fs = require('fs')

fs.readFile(__dirname + './files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})
```

## 2.2 path路径模块

### 2.2.1 什么是path路径模块?
path模块是Node.js中官方提供，用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径处理的需求

例如:
- `path.join()`方法用来拼接路径`
- `path.basename()`方法用来从路径字符串中，将文件名解析出来`

当然如果要在JavaScript代码中，使用path模块来处理路径，则需要先导入模块，代码如下:

```javascript
const path = require('path');
```

### 2.2.2 path.join()方法

使用`path.join()`方法来拼接路径，可以把多个路径片段拼接成一个完整的路径字符串,代码如下:

- 示例一:

```javascript
// 导入模块
const path = require('path')
const pathStr = path.join('/a', '/b/c', '../', './d','e')
// 注意../是可以抵消一层路径的
console.log(pathStr) // 输出结果: \a\b\d\e
```

- 示例二:

```javascript
// 导入模块
const path = require('path')
const pathStr1 = path.join(__dirname, './files/1.txt')
console.log(pathStr1) 

// 输出结果: D:\Node.js基础\day1\CODE.\files\1.txt
// 这里是根据我电脑上的路径来写的,只做演示作用
```
示例二的方法更加方便简洁，因此在实际开发中，我们推荐使用示例二。


在今后的开发中，凡是涉及到路径拼接的操作，都要使用path.join()方法来拼接路径，不要直接使用 + 进行字符串的拼接

- 示例代码:

```javascript
const fs = require('fs');
const path = require('path');

fs.readFile(path.join(__dirname, '/files/example.txt'), 'utf8', (err, dataStr) => {
    if (err) {
        console.error('文件读取失败', err.message);
    }
    console.log(dataStr);
})

// 输出结果:
path.join路径演示
```

### 2.2.3 path.basename()方法

#### path.basename() 的语法格式:
使用path.basename()方法可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:

```javascript
path.basename(pathp[, ext])
```

- path <string> 必选参数
- ext <string> 可选参数, 表示文件扩展名
- 返回: <string> 表示路径中的最后一部分

#### path.basename() 的使用示例:

```javascript
const path = require('path');
const fpath = '/a/b/c/index.html';

var fullName = path.basename(fpath);
console.log(fullName); // 输出结果: index.html
```

```javascript
const path = require('path')
const gpath = '/a/b/c/index.html'

// 参数二为可选参数, 表示文件扩展名
var nameWithoutExt = path.basename(gpath, '.html')
consolo.log(nameFullName) // 输出结果: index
```

### 2.2.4 path.extname()
#### path.extname()的语法格式:

使用path.extname()方法,可以获取路径中你的扩展名部分, 语法格式如下:

```javascript
path.extname(path)
```

- path<string>必选参数，表示一个路径的字符串
- 返回<string>返回得到的扩展名字符串

#### path.extname()的代码示例:

```javascript
const path = require('path')
// 这是文件的存放路径
const fpath = '/a/b/c/index.html'

const fext = path.extname(fpath)
console.log(fext)

// 输出结果：.html
```

### 2.2.5 时钟案例

接下来我将演示一个时钟案例，此案例目的是为了能够让学习者更好的理解node.js中模块化的设定和使用。

这是我们要解耦的html文件中的源码:
可以看到该源码中包含了`css` 和 `javascript`部分 后面我们将对这`两部分`进行解耦

```javascript collapse={20-75}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>index首页</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-image: linear-gradient(to bottom right, red, gold);
    }

    .box {
      width: 400px;
      height: 250px;
      background-color: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      box-shadow: 1px 1px 10px #fff;
      text-shadow: 0px 1px 30px white;

      display: flex;
      justify-content: space-around;
      align-items: center;
      font-size: 70px;
      user-select: none;
      padding: 0 20px;

      /* 盒子投影 */
      -webkit-box-reflect: below 0px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0%, transparent), to(rgba(250, 250, 250, .2)));
    }
  </style>
</head>

<body>
  <div class="box">
    <div id="HH">00</div>
    <div>:</div>
    <div id="mm">00</div>
    <div>:</div>
    <div id="ss">00</div>
  </div>

  <script>
    window.onload = function () {
      // 定时器，每隔 1 秒执行 1 次
      setInterval(() => {
        var dt = new Date()
        var HH = dt.getHours()
        var mm = dt.getMinutes()
        var ss = dt.getSeconds()

        // 为页面上的元素赋值
        document.querySelector('#HH').innerHTML = padZero(HH)
        document.querySelector('#mm').innerHTML = padZero(mm)
        document.querySelector('#ss').innerHTML = padZero(ss)
      }, 1000)
    }

    // 补零函数
    function padZero(n) {
      return n > 9 ? n : '0' + n
    }
  </script>
</body>

</html>
```

- 创建一个clock.js文件

创建一个名为clock.js的文件，并写入以下代码:

```javascript collapse={20-78}
// 1.导入模块
const fs = require('fs')
const path = require('path')

// 2.创建正则表达式,用于匹配对应的字符串
// 2.1.匹配style标签
const regiStyle = /<style>[\s\S]*<\/style>/
// 2.2.匹配script标签
const regiScript = /<script>[\s\S]*<\/script>/

// 调用fs.readFile()方法,读取文件
fs.readFile(path.join(__dirname, './index.html'), 'utf8', function (err, dataStr) {
    if(err) {
        return console.log('读取文件失败！' + err.message)
    }
    console.log('读取文件成功！', dataStr)

    // 调用方法, 传入dataStr读取到的内容

    // 1.拆分HTML中的Css结构方法
    resoloveCss(dataStr)

    // 2.拆分HTML中的JS结构方法
    resolveJs(dataStr)

    // 3.创建Html文件
    resolveHtml(dataStr)

})

// 创建方法
// 1.resolve CSS 方法
function resoloveCss(htmlStr) {
    // 1.提取(匹配html页面中符合条件的字符串)
    const r1 = registStyle.exec(htmlStr)
    console.log(r1);
    
    // 2.替换
    const newCss = r1[0].replace('<style>', '').replace('</style>', '')
    console.log('替换后的newHtml为:', newCss);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newCss.css'), newCss, function (err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
} 

// 2.resolveJs()方法
function resolveJs(htmlData) {
    // 1.提取(符合的字符串) 匹配成功则返回数组,失败则返回null
    const s1 = registScript.exec(htmlData)
    console.log(s1);
    // 2.替换
    const newS1 = s1[0].replace('<script>', '').replace('</script>', '')
    console.log('newS1替换结构为:', newS1);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newJs.js'), newS1, function(err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}

// 3.创建Html文件
function resolveHtml(htmlData) {
    const newHtml = htmlData.replace(registStyle, '<link rel="stylesheet" href="./newCss.css">').replace(registScript, '<script src="./newJs.js"></script>')
    console.log('newHtml打印结果:', newHtml);
    
    fs.writeFile(path.join(__dirname, './files/newHtml.html'), newHtml, function(err) { 
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}
```

运行这个代码，会生成一个名为 `newHtml.html` 的文件，并写入新的 HTML 内容。
将`原本的index.html`中`html css javascript`的内容全部分离出来，并逐个写入`新的文件`中,最后在通过`html的link方法引入css和JavaScript文件`，完成页面的`模块化`，这点与Vue框架并无太大差别

## 2.3 http模块

### 2.3.1 什么是http模块？
在认识到`http模块`之前，我们先了解一些`概念`：

- 什么是客户端，什么是服务器?

    在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

- 而http模块是什么呢?

    `http模块`是Node.js官方提供的、用来`创建Web服务器的模块`。通过http模块提供的`http.createServer()`方法，就能方便的把一台普通电脑，变成一台Web服务器，从而对外提供web资源服务。

### 2.3.2 如何使用http模块

如果希望使用http模块，首先需要引入该模块：

```javascript
const http = require('http');
```

### 2.3.3 进一步理解http模块的作用

服务器和普通电脑的`区别`在于，服务器上安装了web服务器软件，例如：IIS、Apache等。通过安装这些服务器软件，就能把一台电脑变成一台web服务器。