---
title: Node.js学习
published: 2026-02-10
description: 学习Node.js笔记
tags: [后端]
category: 后端
licenseName: "CC BY-NC-SA 4.0"
author: Aloha
sourceLink: "https://github.com/emn178/markdown"
image: ./images/Node.js学习cover.webp
draft: false
date: 2026-02-10 
pubDate: 2025-02-10
---

# Node.js学习

## 一、初识Node.js

### 1.1 Node.js是什么?
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用 JavaScript 编写，并且 Node.js 是一个事件驱动的，非阻塞的，基于 I/O 的异步操作的 JavaScript 运行环境。

### 1.2 Node.js的核心特性
Npde.js 的核心特性有：
- 基于事件驱动，非阻塞的异步 I/O
- 模块化
- 跨平台
- 快速、高效
- 丰富的第三方模块

### 使用Node运行JavaScript代码
Node.js 运行 JavaScript 代码的方式有很多，最常用的是使用 Node.js 的命令行工具。
当我们要使用Node运行一个js文件时，可以使用以下命令：
```bash
node Node_Example.js
# 运行结果：
HELLO Node.js
```
## 二、Node.js 的模块系统

## 2.1 fs模块
fs模块是Node.js最常用的模块，主要是对文件进行读写、创建、删除、修改、移动等操作。

它的导入方法也很简单，使用require()方法导入即可
```javascript
const fs = require('fs');
```
### 2.1.1 读取文件内容

```javascript
# // 导入fs 模块
const fs = require('fs')
// 操作文件
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) {
    # // 打印失败的结果
    # // 如果读取成功则err的值为null
    # // 如果读取失败则err的值为错误信息 undefined
    console.log(err);
    console.log("-----");
    # // 打印成功的结果
    console.log(dataStrs);
})

# 1.txt 文件内容的输出结果:
null
-----
1111
```

### 2.1.2 异步读取文件

```javascript
const fs = require('fs')
fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message)
    }
    return console.log('文件读取成功', dataStrs)
})
# 输出结果:
文件读取成功 1111
```

### 2.1.3 写入文件内容
- 使用fs.writeFile()方法写入文件内容, 可以向指定的文件中写入内容，语法格式如下:

```javascript
fs.writeFile(file, data[, options], callback])
```
- 注意：当我们重复调用fs.writeFile()方法写入文件的时候，会覆盖掉之前的内容。

- fs.writeFile()的示例代码:

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/2.txt', 'hello world', function(err){
# // 如果没有出错，则返回null，如果出错，则返回错误信息
    console.log(err);
})
# 输出结果:
null
```

### 2.1.4 异步写入文件内容

```javascript
const fs = require('fs')
# //  调用fs.writeFile方法写入文件内容 
# // 参数1：写入文件的路径
# // 参数2：写入的内容
# // 参数3：回调函数
fs.writeFile('./files/3.txt', 'hello world', function(err){
// 如果没有出错，则返回null，如果出错，则返回错误信息undefined
if(err){
    return console.log('写入失败', err.message)
}
    console.log('3.txt,写入成功');
})
# 输出结果为:
3.txt,写入成功
```
### 2.1.5 成绩整理案例：

此案例是结合前面fs模块的读写操作进行对成绩.txt文件的操作，将读取到的内容进行整理，并写入新的文件中。

```javascript
const fs = require('fs')
fs.readFile('./files/成绩.txt', 'utf-8', function (err, dataStrs) { 
    if (err) {
        return console.log('文件读取失败', err.message);
    }
    console.log('文件读取成功', dataStrs);

    // 1.将数据进行分割
    const arrOld = dataStrs.split(' ')
    console.log(arrOld);

    // 2.遍历分割后的数据成为一个新数组
    const arrNew = []
    arrOld.forEach(item => {
        arrNew.push(item.replace('=', ': '))
    });
    console.log(arrNew);

    // 3.进行数据的拼接
    const newStr = arrNew.join('\r\n')
    console.log(newStr);
    
    // 4.将拼接后的数据写入到文件中
    fs.writeFile('./files/整理后的成绩.txt', newStr, function (err) { 
        if (err) {
            return console.log('文件写入失败', err.message)
        }
        return console.log('文件写入成功')
})
})

// 输出结果：
小红: 99
小白: 100
小黄: 70
小黑: 66
小绿: 88
文件写入成功
```

### 2.1.6 fs模块-路径动态拼接的问题

在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的相对路径，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径

示例代码：

```javascript
const fs = require('fs')

fs.readFile('./files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})

```
```bash
# 当我们没有处在node.js的根目录下时，在控制台执行以下命令时，会出现报错，文件无法被读取
node ./code/ndoe 动态路径错误问题.js
```

- 解决方法：使用`__dirname`来获取当前文件的所在目录，并拼接成完整的文件路径

示例代码:

```javascript
const fs = require('fs')

fs.readFile(__dirname + './files/1.txt', 'utf-8', function (err, dataStrs) { 
    if(err) {
        return console.log('文件读取失败', err.message)
    }
    console.log('文件读取成功', dataStrs);
    
})
```

## 2.2 path路径模块

### 2.2.1 什么是path路径模块?
path模块是Node.js中官方提供，用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径处理的需求

例如:
- `path.join()`方法用来拼接路径`
- `path.basename()`方法用来从路径字符串中，将文件名解析出来`

当然如果要在JavaScript代码中，使用path模块来处理路径，则需要先导入模块，代码如下:

```javascript
const path = require('path');
```

### 2.2.2 path.join()方法

使用`path.join()`方法来拼接路径，可以把多个路径片段拼接成一个完整的路径字符串,代码如下:

- 示例一:

```javascript
// 导入模块
const path = require('path')
const pathStr = path.join('/a', '/b/c', '../', './d','e')
// 注意../是可以抵消一层路径的
console.log(pathStr) // 输出结果: \a\b\d\e
```

- 示例二:

```javascript
// 导入模块
const path = require('path')
const pathStr1 = path.join(__dirname, './files/1.txt')
console.log(pathStr1) 

// 输出结果: D:\Node.js基础\day1\CODE.\files\1.txt
// 这里是根据我电脑上的路径来写的,只做演示作用
```
示例二的方法更加方便简洁，因此在实际开发中，我们推荐使用示例二。


在今后的开发中，凡是涉及到路径拼接的操作，都要使用path.join()方法来拼接路径，不要直接使用 + 进行字符串的拼接

- 示例代码:

```javascript
const fs = require('fs');
const path = require('path');

fs.readFile(path.join(__dirname, '/files/example.txt'), 'utf8', (err, dataStr) => {
    if (err) {
        console.error('文件读取失败', err.message);
    }
    console.log(dataStr);
})

// 输出结果:
path.join路径演示
```

### 2.2.3 path.basename()方法

#### path.basename() 的语法格式:
使用path.basename()方法可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:

```javascript
path.basename(pathp[, ext])
```

- path <string> 必选参数
- ext <string> 可选参数, 表示文件扩展名
- 返回: <string> 表示路径中的最后一部分

#### path.basename() 的使用示例:

```javascript
const path = require('path');
const fpath = '/a/b/c/index.html';

var fullName = path.basename(fpath);
console.log(fullName); // 输出结果: index.html
```

```javascript
const path = require('path')
const gpath = '/a/b/c/index.html'

// 参数二为可选参数, 表示文件扩展名
var nameWithoutExt = path.basename(gpath, '.html')
consolo.log(nameFullName) // 输出结果: index
```

### 2.2.4 path.extname()
#### path.extname()的语法格式:

使用path.extname()方法,可以获取路径中你的扩展名部分, 语法格式如下:

```javascript
path.extname(path)
```

- path<string>必选参数，表示一个路径的字符串
- 返回<string>返回得到的扩展名字符串

#### path.extname()的代码示例:

```javascript
const path = require('path')
// 这是文件的存放路径
const fpath = '/a/b/c/index.html'

const fext = path.extname(fpath)
console.log(fext)

// 输出结果：.html
```

### 2.2.5 时钟案例

接下来我将演示一个时钟案例，此案例目的是为了能够让学习者更好的理解node.js中模块化的设定和使用。

这是我们要解耦的html文件中的源码:
可以看到该源码中包含了`css` 和 `javascript`部分 后面我们将对这`两部分`进行解耦

```javascript collapse={20-75}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>index首页</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-image: linear-gradient(to bottom right, red, gold);
    }

    .box {
      width: 400px;
      height: 250px;
      background-color: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      box-shadow: 1px 1px 10px #fff;
      text-shadow: 0px 1px 30px white;

      display: flex;
      justify-content: space-around;
      align-items: center;
      font-size: 70px;
      user-select: none;
      padding: 0 20px;

      /* 盒子投影 */
      -webkit-box-reflect: below 0px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0%, transparent), to(rgba(250, 250, 250, .2)));
    }
  </style>
</head>

<body>
  <div class="box">
    <div id="HH">00</div>
    <div>:</div>
    <div id="mm">00</div>
    <div>:</div>
    <div id="ss">00</div>
  </div>

  <script>
    window.onload = function () {
      // 定时器，每隔 1 秒执行 1 次
      setInterval(() => {
        var dt = new Date()
        var HH = dt.getHours()
        var mm = dt.getMinutes()
        var ss = dt.getSeconds()

        // 为页面上的元素赋值
        document.querySelector('#HH').innerHTML = padZero(HH)
        document.querySelector('#mm').innerHTML = padZero(mm)
        document.querySelector('#ss').innerHTML = padZero(ss)
      }, 1000)
    }

    // 补零函数
    function padZero(n) {
      return n > 9 ? n : '0' + n
    }
  </script>
</body>

</html>
```

- 创建一个clock.js文件

创建一个名为clock.js的文件，并写入以下代码:

```javascript collapse={20-78}
// 1.导入模块
const fs = require('fs')
const path = require('path')

// 2.创建正则表达式,用于匹配对应的字符串
// 2.1.匹配style标签
const regiStyle = /<style>[\s\S]*<\/style>/
// 2.2.匹配script标签
const regiScript = /<script>[\s\S]*<\/script>/

// 调用fs.readFile()方法,读取文件
fs.readFile(path.join(__dirname, './index.html'), 'utf8', function (err, dataStr) {
    if(err) {
        return console.log('读取文件失败！' + err.message)
    }
    console.log('读取文件成功！', dataStr)

    // 调用方法, 传入dataStr读取到的内容

    // 1.拆分HTML中的Css结构方法
    resoloveCss(dataStr)

    // 2.拆分HTML中的JS结构方法
    resolveJs(dataStr)

    // 3.创建Html文件
    resolveHtml(dataStr)

})

// 创建方法
// 1.resolve CSS 方法
function resoloveCss(htmlStr) {
    // 1.提取(匹配html页面中符合条件的字符串)
    const r1 = registStyle.exec(htmlStr)
    console.log(r1);
    
    // 2.替换
    const newCss = r1[0].replace('<style>', '').replace('</style>', '')
    console.log('替换后的newHtml为:', newCss);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newCss.css'), newCss, function (err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
} 

// 2.resolveJs()方法
function resolveJs(htmlData) {
    // 1.提取(符合的字符串) 匹配成功则返回数组,失败则返回null
    const s1 = registScript.exec(htmlData)
    console.log(s1);
    // 2.替换
    const newS1 = s1[0].replace('<script>', '').replace('</script>', '')
    console.log('newS1替换结构为:', newS1);
    // 3.写入
    fs.writeFile(path.join(__dirname, './files/newJs.js'), newS1, function(err) {
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}

// 3.创建Html文件
function resolveHtml(htmlData) {
    const newHtml = htmlData.replace(registStyle, '<link rel="stylesheet" href="./newCss.css">').replace(registScript, '<script src="./newJs.js"></script>')
    console.log('newHtml打印结果:', newHtml);
    
    fs.writeFile(path.join(__dirname, './files/newHtml.html'), newHtml, function(err) { 
        if(err) {
            return console.log('写入文件失败', err.message);
        }
        console.log('写入文件成功');
    })
}
```

运行这个代码，会生成一个名为 `newHtml.html` 的文件，并写入新的 HTML 内容。
将`原本的index.html`中`html css javascript`的内容全部分离出来，并逐个写入`新的文件`中,最后在通过`html的link方法引入css和JavaScript文件`，完成页面的`模块化`，这点与Vue框架并无太大差别

## 2.3 http模块

### 2.3.1 什么是http模块？
在认识到`http模块`之前，我们先了解一些`概念`：

- 什么是客户端，什么是服务器?

    在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

- 而http模块是什么呢?

    `http模块`是Node.js官方提供的、用来`创建Web服务器的模块`。通过http模块提供的`http.createServer()`方法，就能方便的把一台普通电脑，变成一台Web服务器，从而对外提供web资源服务。

### 2.3.2 如何使用http模块

如果希望使用http模块，首先需要引入该模块：

```javascript
const http = require('http');
```

### 2.3.3 进一步理解http模块的作用

服务器和普通电脑的`区别`在于，服务器上安装了web服务器软件，例如：IIS、`Apache`等。通过安装这些服务器软件，就能把一台电脑变成一台web服务器。

在Node.js中，我们不需要使用IIS、Apache等这些第三方服务器软件，因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。

### 2.3.4 服务器相关的概念

1. #### IP地址：

    `IP地址`就是相当于互联网上每台计算机的唯一地址，因此IP地址具有唯一性，如果把“个人电脑”比作一台电话，那么IP地址就是这个电话的电话号码，只有在知道对方IP地址的前提下，才能对应电脑之间进行数据通信。

    `IP地址的格式`: 通常用`点分十进制`表示成(`a.b.c.d`)的形式，其中a,b,c,d都是0-255之间的十进制整数。例如：用点分十进制表示的IP地址(192.168.1.1)

    - 注意:

        1. `互联网中每台web服务器，都有自己的IP地址`， 例如：大家可以在Windows的终端中运行 `ping www.baidu.com` 命令，就会看到百度的IP地址。

        2. 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP地址，就可以访问到自己的电脑。

2. #### `域名`和`域名服务器`

    尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，`不直观`，而且`不方便于记忆`，雨伞人们又发明了另一套字`符串型`的`地址方案`，即所谓的`域名(Domain Name)地址`。

    `IP地址`和`域名`是`一一对应的关系`，这份对应关系存放在一种叫做`域名服务器`(DNS, Domain Name Server)的电脑中。只需要通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现，因此，`域名服务器就是提供IP地址和域名之间的转换服务的服务器`

    - 注意:

        1. 单纯使用IP地址，互联网中的电脑也能够正常工作，但是有了域名的加持，能让互联网的世界变得更加方便。

        2. 在开发测试期间， `127.0.0.1`对应的域名是`localhost`，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

3. #### 端口号

    计算机中的端口号，就好像是现实生活中的门牌号一样，通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你手中。

    同样的道理，在一台电脑中，可以运行成百上千个web服务，每个web服务都对应一个唯一的端口号，客户端发送过来的网络请求，通过端口号，可以被准确地交给`对应的web服务`进行处理

    - 注意:
        1. 每个端口号不能同时被多个web服务占用
        2. 在实际应用中，URL中的80端口可以被省略

### 2.3.5 创建最基本的web服务器

1. #### 创建web服务器的基本步骤
    1. 导入http模块
    2. 创建web服务器实例
    3. 为服务器实例绑定`request`事件，`监听客户端的请求`
    4. 启动服务器

    2. #### 步骤一 - 导入http模块

    ```javascript
    const http = require('http');
    ```

    3. #### 步骤二 - 创建web服务器实例

        调用`http.createServer()`方法创建一个web服务器实例

    ```javascript
    const server = http.createServer();
    ```

    4. #### 步骤三 - 为服务器实例绑定`request`事件，`监听客户端的请求`

        为服务器实例绑定`request`事件，即可监听客户端发送的网络请求

    ```javascript
    // 使用服务器实例的 .on 方法，为服务器实例绑定 request 事件
    server.on('request', (req, res) => {
        // 只要有客户端来请求外卖自己的服务器，就会触发request事件，从而调用这个事件处理函数
        console.log('Someone has made a request to our server!');
    })
    ```

    5. #### 步骤四 - 启动服务器

        调用服务器实例的 .listen 方法，即可启动当前的web服务器实例:

    ```javascript
    // 调用server.listen(端口号，cb回调)， 即可启动服务器
    server.listen(80, () => {
        console.log('Our server is running!');
    })
    ```

2. #### req请求对象

    只要服务器接收到了客户端的请求，就会调用通过`server.on()`为服务器绑定`request事件处理函数`

    如果想在事件处理器函数中，`访问与客户端相关的数据或属性`, 可以使用如下的方式:

    ```javascript
    const http = require('http');
    const server = http.createServer();
    server.on('request', (req) => {
        // req是请求对象，它包含了与客户端相关的数据和属性，例如:
        // req.url 是客户端请求的URL地址
        const url = req.url;
        // req.method 是客户端的method请求类型
        const method = req.method;
        // 拼接url和method  
        const str = `You request url is ${method} and request method is ${url}`;
        // 打印str
        console.log(str);

    })
    server.listen(80, () => {
        console.log('server running at http://127.0.0.1');
    })
    ```

### 2.3.6 res响应对象

在服务器的request事件处理函数中，`如果想访问与服务器相关的数据或属性`,可以使用如下的方式：

```javascript
server.on('request', (req, res) => {
    //  res 是响应对象，它包含了与服务器相关的数据和属性，例如：
    // 要发送到客户端的字符串
    const str = `You request url is ${req.url} and request method is ${req.method}`
    // res.end 方法的作用:
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})
```

#### 解决`中文乱码`问题

当调用res.end()方法时，Node.js会默认将数据转换成UTF-8编码，但是对于中文字符，这个编码方式能会导致乱码, 此时, 需要手动设置内容的编码格式, 解决办法也很简单, 设置响应头
Content-Type: text/html; charset=utf-8即可

```javascript
server.on('request', (req, res) => {
    const str = '中文乱码'
    // 设置响应头
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    // 返回响应数据
    res.end(str)
})
```

### 2.3.7 根据不同的url响应不同的html内容

1. 核心实现步骤
    - 获取`请求的url地址`
    - 设置`默认的响应内容`为`404 Not Found`
    - 判断用户请求的是否为`/`或者`/index.html`首页
    - 判断用户请求的是否为`/about.html`关于页面
    - 设置Content-Type响应头
    - 使用`res.end()`方法把内容，响应给客户端

2. 示例代码

    ```javascript
    const http = require('http');
    const server = http.createServer()
    server.on('request', (req, res) => {
        const url = req.url;
        // 设置默认的内容为 404 Not Found
        let content = `<h1>'404 Not Found'</h1>`;
        if(url === '/') {
            content = `<h1>'首页'</h1>`;
        }else if(url === '/about.html') {
            content = `<h1>'关于'</h1>`;
        }
        // 设置响应头 防止中文乱码
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        // 返回 页面content 的响应内容
        res.end(content);
    })
    server.listen(80, () => {
        console.log('http server running at http://127.0.0.1');
    })
    ```

### 2.3.8 http时钟web服务器案例

在path路径模块的章节中，我们已经实现了一个http时钟服务器，现在我们来实现一个http时钟服务器，这个服务器会返回当前时间。

```javascript
const fs = require('fs');
const path = require('path');
const http = require('http');

const server = http.createServer();

server.on('request',(req,res) => { 

    const url = req.url;
    // 这里的所表达的意思是代表根目录的意思
    const fpath = path.join(__dirname, url);

    fs.readFile(fpath, 'utf-8', (err, dataStr) => {
        if(err) {
            res.end('404 Not Found')
            return
        }
        res.end(dataStr)
    })
   
})
server.listen(80, () => {
    console.log('http server running at http://127.0.0.1');
})
```

`需要注意的时候，当我们运行这个服务器，进入的默认URL是空路径，也就是根目录，需要我们手动在网址输入框添加/clock/index.html路径访问这个文件夹中的html文件，才能显示页面。`

## 三、模块化的概念

### 3.1 什么是模块化?

在编程领域中的模块化，就是`遵守固定的规则`，把一个大文件拆成`独立并互相依赖`的`多个小模块`。

把代码进行模块化拆分的好处是:

1. 提高了代码的`复用性`
2. 提高了代码的`可维护性`
3. 可以实现`按需加载`
